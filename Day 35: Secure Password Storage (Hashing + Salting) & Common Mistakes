âœ… Day 35: Secure Password Storage (Hashing + Salting) & Common Mistakes
ğŸ¯ Goal

Understand how passwords should be stored securely in real-world applications and what mistakes lead to leaks.

ğŸ”‘ What is Password Hashing?

Password hashing means converting a password into a fixed-length string using a one-way function.

âœ… One-way = you cannot get the original password back from the hash.

Example:
password123 â†’ 5f4dcc3b5aa765d61d8327deb882cf99 (hash)

ğŸ§‚ Why Salting is Important

A salt is a random string added to the password before hashing.

âœ… Benefits of Salting:

Prevents same passwords having same hash

Protects against rainbow table attacks

Makes brute force harder

Example:
password123 + X9!aP â†’ hash output changes completely

ğŸ”¥ Why Plain Hashing is Still Not Enough

Even with hashing, attackers can brute-force quickly if hashing is fast.

So we use slow hashing algorithms designed for passwords:

âœ… Recommended:

bcrypt

scrypt

Argon2 (best today)

ğŸš« Avoid for passwords:

MD5

SHA-1

SHA-256 (fast, not meant for password storage)

âš ï¸ Common Real-World Mistakes

âŒ Storing passwords in plaintext
âŒ Using MD5/SHA without salt
âŒ Same salt for every user
âŒ Low cost factor in bcrypt (too fast)
âŒ Logging passwords in console/server logs

âœ… Best Practices

âœ… Hash + Salt every password
âœ… Use bcrypt/Argon2 with proper cost
âœ… Store only hash (never store original password)
âœ… Apply rate limiting + lockouts to stop brute force
âœ… Use password policies + strength checks

ğŸ’¡ Mini Takeaway

Passwords should never be reversible.
If the database leaks, the attacker should still struggle hard to crack user passwords.

âœ… What Iâ€™ll do next

Implement bcrypt hashing + verification in a login system

Add password strength validation

Add rate limiting to stop brute-force attacks
