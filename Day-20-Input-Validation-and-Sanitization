# Day 20 – Input Validation & Sanitization

## What this is about
Revisiting input validation and sanitization with a focus on practical security impact.

## Why this matters
Improper input handling is one of the root causes of:
- Cross-Site Scripting (XSS)
- SQL Injection
- Command Injection

## Key takeaway
Never trust user input — validate what you expect, sanitize what you display.

## Real-world impact
Improper input validation has caused major security breaches in the real world:
- XSS leading to session hijacking
- SQL Injection exposing entire databases
- Command Injection resulting in server takeover

## Common developer mistakes
- Trusting client-side validation alone
- Using blacklists instead of whitelists
- Not validating input length and type
- Forgetting to sanitize output before rendering

## Validation vs Sanitization
- **Validation**: Checking if input matches expected format and rules
  - Example: Only numbers for age, valid email format, allowed characters
- **Sanitization**: Cleaning or escaping input before using or displaying it
  - Example: Escaping HTML to prevent XSS

Validation decides *whether* input is acceptable.  
Sanitization decides *how* input is safely used.

Most of these attacks happen not because of complex bugs,
but because basic input checks were skipped.

## Common developer mistakes
- Trusting client-side validation alone
- Using blacklists instead of whitelists
- Not validating input length and type
- Forgetting to sanitize output before rendering

## Best practices
- Always validate input on the server side
- Use allowlists instead of denylists
- Apply strict input length limits
- Encode output based on context (HTML, JS, SQL)
- Treat all external input as untrusted

## Types of validation
- **Format validation**: Ensuring input follows a pattern (email, phone)
- **Type validation**: Ensuring correct data type (int, string, boolean)
- **Range validation**: Ensuring values fall within allowed limits
- **Length validation**: Restricting minimum and maximum input size
